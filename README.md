# Super devs recruitment task

## Requirements
You are going to write a simple backend application that exposes data - extracted from a csv file - via an API. 
Possible queries might look like this: 
* Total Clicks for a given Datasource for a given Date range 
* Click-Through Rate (CTR) per Datasource and Campaign 
* Impressions over time (daily) 

And the data looks like this: 
* a time dimension (Date) 
* regular dimensions (Campaign, Datasource) 
* metrics (Clicks, Impressions) 

As a hint, the API consumes these parameters 
* a set of metrics (plus calculated ones) to be aggregated on 
* an optional set of dimensions to be grouped by 
* an optional set of dimension filters to be filtered on 

## Solution

### Sample data & datastore
Since this is just a simple demo task I decided to go with h2 in memory db as its the easiest to set up and requires no special handling for users wanting to launch the solution
H2 should not be used for production use, project needs to be reconfigured to use some more reliable data store (mysql, maria, postgres etc)

Db structure and sample data is created via liquibase changelog, due to its ease of use and import of csv data directly into db.
I also transformed the `daily` to proper date format in case if it would be needed to search using `greater than` or `less than` operators

### Metrics calculations and how to extend the solution
Supported metrics are listed in the `com.example.demo.model.Metric`.
Each metric is associated with a calculator. Each calculator needs to implement `com.example.demo.service.MetricCalculator`
All implementations of `com.example.demo.service.MetricCalculator` are injected into service which picks correct calculator for given metric.
Then the service calls the calculator and returns the result.

This approach allows us to easily extend the solution by simply adding new enum values in the `com.example.demo.model.Metric`
and implementing corresponding calculator that extends the `com.example.demo.service.MetricCalculator`

For convenience all my calculators extend `com.example.demo.service.BaseMetricCalculator` that fetches data from db.
`com.example.demo.service.BaseMetricCalculator` contains methods for generating proper queries depending on the provided filters.

Implemented filtering contains only 3 operators (listed in `com.example.demo.model.FilterOperator`) for demo purpouse.
Filtering capabilities can be easily extended by providing additioal values to `com.example.demo.model.FilterOperator` and 
extending generation of predicates in the `com.example.demo.service.BaseMetricCalculator.toPredicate` method.
Probably it would be better to move this method to some interface and apply similar pattern to what is done in "metric -> calculator" when number of filtering predicates gets bigger.


### Api testing - Swagger
Swagger is added to the project. You can access the swagger-ui at `http://localhost:8080/swagger-ui.html` to call the api.
This page is autogenerated from java code using springfox integration.


### What could be done better if I have more time
Response object should be structured better, to handle scalar values (no grouping) and grouped elements (when grouping is used)
Maybe there should be different handlers for requests with grouping to be able to return different response objects in those cases.

Also had some problem fitting in metrics that change over time into this. Current solution is not very nice since it specifies fields for all possible scenarios 
and the client must know what to expect when requesting certain metric.

For huge datasets probably the approach will need to be different to avoid loading too much data to memory.
Probably there should be some processing on inserting of data and storing calculated results in tables related to concrete metrics,
or maybe even storing only aggregated data after certain time already passed.
